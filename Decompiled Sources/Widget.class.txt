package de.matthiasmann.twl;

import de.matthiasmann.twl.renderer.AnimationState.StateKey;
import de.matthiasmann.twl.renderer.Image;
import de.matthiasmann.twl.renderer.MouseCursor;
import de.matthiasmann.twl.renderer.OffscreenRenderer;
import de.matthiasmann.twl.renderer.OffscreenSurface;
import de.matthiasmann.twl.renderer.Renderer;
import de.matthiasmann.twl.theme.ThemeManager;
import de.matthiasmann.twl.utils.TextUtil;
import de.matthiasmann.twl.utils.TintAnimator;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Widget
{
  public static final AnimationState.StateKey STATE_KEYBOARD_FOCUS = AnimationState.StateKey.get("keyboardFocus");
  public static final AnimationState.StateKey STATE_HAS_OPEN_POPUPS = AnimationState.StateKey.get("hasOpenPopups");
  public static final AnimationState.StateKey STATE_HAS_FOCUSED_CHILD = AnimationState.StateKey.get("hasFocusedChild");
  public static final AnimationState.StateKey STATE_DISABLED = AnimationState.StateKey.get("disabled");
  private static final int LAYOUT_INVALID_LOCAL = 1;
  private static final int LAYOUT_INVALID_GLOBAL = 3;
  private Widget parent;
  private int posX;
  private int posY;
  private int width;
  private int height;
  private int layoutInvalid;
  private boolean clip;
  private boolean visible = true;
  private boolean hasOpenPopup;
  private boolean enabled = true;
  private boolean locallyEnabled = true;
  private String theme;
  private ThemeManager themeManager;
  private Image background;
  private Image overlay;
  private Object tooltipContent;
  private Object themeTooltipContent;
  private InputMap inputMap;
  private ActionMap actionMap;
  private TintAnimator tintAnimator;
  private PropertyChangeSupport propertyChangeSupport;
  volatile GUI guiInstance;
  private OffscreenSurface offscreenSurface;
  private RenderOffscreen renderOffscreen;
  private final AnimationState animState;
  private final boolean sharedAnimState;
  private short borderLeft;
  private short borderTop;
  private short borderRight;
  private short borderBottom;
  private short minWidth;
  private short minHeight;
  private short maxWidth;
  private short maxHeight;
  private short offscreenExtraLeft;
  private short offscreenExtraTop;
  private short offscreenExtraRight;
  private short offscreenExtraBottom;
  private ArrayList<Widget> children;
  private Widget lastChildMouseOver;
  private Widget focusChild;
  private MouseCursor mouseCursor;
  private FocusGainedCause focusGainedCause;
  private boolean focusKeyEnabled = true;
  private boolean canAcceptKeyboardFocus;
  private boolean depthFocusTraversal = true;
  private static final ThreadLocal<Widget[]> focusTransferInfo = new ThreadLocal();
  
  public Widget()
  {
    this(null, false);
  }
  
  public Widget(AnimationState animState)
  {
    this(animState, false);
  }
  
  public Widget(AnimationState animState, boolean inherit)
  {
    Class<?> clazz = getClass();
    do
    {
      this.theme = clazz.getSimpleName().toLowerCase(Locale.ENGLISH);
      clazz = clazz.getSuperclass();
    } while ((this.theme.length() == 0) && (clazz != null));
    if ((animState == null) || (inherit))
    {
      this.animState = new AnimationState(animState);
      this.sharedAnimState = false;
    }
    else
    {
      this.animState = animState;
      this.sharedAnimState = true;
    }
  }
  
  public void addPropertyChangeListener(PropertyChangeListener listener)
  {
    createPropertyChangeSupport().addPropertyChangeListener(listener);
  }
  
  public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener)
  {
    createPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);
  }
  
  public void removePropertyChangeListener(PropertyChangeListener listener)
  {
    if (this.propertyChangeSupport != null) {
      this.propertyChangeSupport.removePropertyChangeListener(listener);
    }
  }
  
  public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener)
  {
    if (this.propertyChangeSupport != null) {
      this.propertyChangeSupport.removePropertyChangeListener(propertyName, listener);
    }
  }
  
  public boolean hasOpenPopups()
  {
    return this.hasOpenPopup;
  }
  
  public final Widget getParent()
  {
    return this.parent;
  }
  
  public final Widget getRootWidget()
  {
    Widget w = this;
    Widget p;
    while ((p = w.parent) != null) {
      w = p;
    }
    return w;
  }
  
  public final GUI getGUI()
  {
    return this.guiInstance;
  }
  
  public final boolean isVisible()
  {
    return this.visible;
  }
  
  public void setVisible(boolean visible)
  {
    if (this.visible != visible)
    {
      this.visible = visible;
      if (!visible)
      {
        GUI gui = getGUI();
        if (gui != null) {
          gui.widgetHidden(this);
        }
        if (this.parent != null) {
          this.parent.childHidden(this);
        }
      }
      if (this.parent != null) {
        this.parent.childVisibilityChanged(this);
      }
    }
  }
  
  public final boolean isLocallyEnabled()
  {
    return this.locallyEnabled;
  }
  
  public final boolean isEnabled()
  {
    return this.enabled;
  }
  
  public void setEnabled(boolean enabled)
  {
    if (this.locallyEnabled != enabled)
    {
      this.locallyEnabled = enabled;
      firePropertyChange("locallyEnabled", !enabled, enabled);
      recursivelyEnabledChanged(getGUI(), this.parent != null ? this.parent.enabled : true);
    }
  }
  
  public final int getX()
  {
    return this.posX;
  }
  
  public final int getY()
  {
    return this.posY;
  }
  
  public final int getWidth()
  {
    return this.width;
  }
  
  public final int getHeight()
  {
    return this.height;
  }
  
  public final int getRight()
  {
    return this.posX + this.width;
  }
  
  public final int getBottom()
  {
    return this.posY + this.height;
  }
  
  public final int getInnerX()
  {
    return this.posX + this.borderLeft;
  }
  
  public final int getInnerY()
  {
    return this.posY + this.borderTop;
  }
  
  public final int getInnerWidth()
  {
    return Math.max(0, this.width - this.borderLeft - this.borderRight);
  }
  
  public final int getInnerHeight()
  {
    return Math.max(0, this.height - this.borderTop - this.borderBottom);
  }
  
  public final int getInnerRight()
  {
    return this.posX + Math.max(this.borderLeft, this.width - this.borderRight);
  }
  
  public final int getInnerBottom()
  {
    return this.posY + Math.max(this.borderTop, this.height - this.borderBottom);
  }
  
  public boolean isInside(int x, int y)
  {
    return (x >= this.posX) && (y >= this.posY) && (x < this.posX + this.width) && (y < this.posY + this.height);
  }
  
  public boolean setPosition(int x, int y)
  {
    return setPositionImpl(x, y);
  }
  
  public boolean setSize(int width, int height)
  {
    if ((width < 0) || (height < 0)) {
      throw new IllegalArgumentException("negative size");
    }
    int oldWidth = this.width;
    int oldHeight = this.height;
    if ((oldWidth != width) || (oldHeight != height))
    {
      this.width = width;
      this.height = height;
      
      sizeChanged();
      if (this.propertyChangeSupport != null)
      {
        firePropertyChange("width", oldWidth, width);
        firePropertyChange("height", oldHeight, height);
      }
      return true;
    }
    return false;
  }
  
  public boolean setInnerSize(int width, int height)
  {
    return setSize(width + this.borderLeft + this.borderRight, height + this.borderTop + this.borderBottom);
  }
  
  public short getBorderTop()
  {
    return this.borderTop;
  }
  
  public short getBorderLeft()
  {
    return this.borderLeft;
  }
  
  public short getBorderBottom()
  {
    return this.borderBottom;
  }
  
  public short getBorderRight()
  {
    return this.borderRight;
  }
  
  public int getBorderHorizontal()
  {
    return this.borderLeft + this.borderRight;
  }
  
  public int getBorderVertical()
  {
    return this.borderTop + this.borderBottom;
  }
  
  public boolean setBorderSize(int top, int left, int bottom, int right)
  {
    if ((top < 0) || (left < 0) || (bottom < 0) || (right < 0)) {
      throw new IllegalArgumentException("negative border size");
    }
    if ((this.borderTop != top) || (this.borderBottom != bottom) || (this.borderLeft != left) || (this.borderRight != right))
    {
      int innerWidth = getInnerWidth();
      int innerHeight = getInnerHeight();
      int deltaLeft = left - this.borderLeft;
      int deltaTop = top - this.borderTop;
      this.borderLeft = ((short)left);
      this.borderTop = ((short)top);
      this.borderRight = ((short)right);
      this.borderBottom = ((short)bottom);
      if ((this.children != null) && ((deltaLeft != 0) || (deltaTop != 0)))
      {
        int i = 0;
        for (int n = this.children.size(); i < n; i++) {
          adjustChildPosition((Widget)this.children.get(i), deltaLeft, deltaTop);
        }
      }
      setInnerSize(innerWidth, innerHeight);
      borderChanged();
      return true;
    }
    return false;
  }
  
  public boolean setBorderSize(int horizontal, int vertical)
  {
    return setBorderSize(vertical, horizontal, vertical, horizontal);
  }
  
  public boolean setBorderSize(int border)
  {
    return setBorderSize(border, border, border, border);
  }
  
  public boolean setBorderSize(Border border)
  {
    if (border == null) {
      return setBorderSize(0, 0, 0, 0);
    }
    return setBorderSize(border.getBorderTop(), border.getBorderLeft(), border.getBorderBottom(), border.getBorderRight());
  }
  
  public short getOffscreenExtraTop()
  {
    return this.offscreenExtraTop;
  }
  
  public short getOffscreenExtraLeft()
  {
    return this.offscreenExtraLeft;
  }
  
  public short getOffscreenExtraBottom()
  {
    return this.offscreenExtraBottom;
  }
  
  public short getOffscreenExtraRight()
  {
    return this.offscreenExtraRight;
  }
  
  public void setOffscreenExtra(int top, int left, int bottom, int right)
  {
    if ((top < 0) || (left < 0) || (bottom < 0) || (right < 0)) {
      throw new IllegalArgumentException("negative offscreen extra size");
    }
    this.offscreenExtraTop = ((short)top);
    this.offscreenExtraLeft = ((short)left);
    this.offscreenExtraBottom = ((short)bottom);
    this.offscreenExtraRight = ((short)right);
  }
  
  public void setOffscreenExtra(Border offscreenExtra)
  {
    if (offscreenExtra == null) {
      setOffscreenExtra(0, 0, 0, 0);
    } else {
      setOffscreenExtra(offscreenExtra.getBorderTop(), offscreenExtra.getBorderLeft(), offscreenExtra.getBorderBottom(), offscreenExtra.getBorderRight());
    }
  }
  
  public int getMinWidth()
  {
    return Math.max(this.minWidth, this.borderLeft + this.borderRight);
  }
  
  public int getMinHeight()
  {
    return Math.max(this.minHeight, this.borderTop + this.borderBottom);
  }
  
  public void setMinSize(int width, int height)
  {
    if ((width < 0) || (height < 0)) {
      throw new IllegalArgumentException("negative size");
    }
    this.minWidth = ((short)Math.min(width, 32767));
    this.minHeight = ((short)Math.min(height, 32767));
  }
  
  public int getPreferredInnerWidth()
  {
    int right = getInnerX();
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++)
      {
        Widget child = (Widget)this.children.get(i);
        right = Math.max(right, child.getRight());
      }
    }
    return right - getInnerX();
  }
  
  public int getPreferredWidth()
  {
    int prefWidth = this.borderLeft + this.borderRight + getPreferredInnerWidth();
    Image bg = getBackground();
    if (bg != null) {
      prefWidth = Math.max(prefWidth, bg.getWidth());
    }
    return Math.max(this.minWidth, prefWidth);
  }
  
  public int getPreferredInnerHeight()
  {
    int bottom = getInnerY();
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++)
      {
        Widget child = (Widget)this.children.get(i);
        bottom = Math.max(bottom, child.getBottom());
      }
    }
    return bottom - getInnerY();
  }
  
  public int getPreferredHeight()
  {
    int prefHeight = this.borderTop + this.borderBottom + getPreferredInnerHeight();
    Image bg = getBackground();
    if (bg != null) {
      prefHeight = Math.max(prefHeight, bg.getHeight());
    }
    return Math.max(this.minHeight, prefHeight);
  }
  
  public int getMaxWidth()
  {
    return this.maxWidth;
  }
  
  public int getMaxHeight()
  {
    return this.maxHeight;
  }
  
  public void setMaxSize(int width, int height)
  {
    if ((width < 0) || (height < 0)) {
      throw new IllegalArgumentException("negative size");
    }
    this.maxWidth = ((short)Math.min(width, 32767));
    this.maxHeight = ((short)Math.min(height, 32767));
  }
  
  public static int computeSize(int min, int preferred, int max)
  {
    if (max > 0) {
      preferred = Math.min(preferred, max);
    }
    return Math.max(min, preferred);
  }
  
  public void adjustSize()
  {
    setSize(computeSize(getMinWidth(), getPreferredWidth(), getMaxWidth()), computeSize(getMinHeight(), getPreferredHeight(), getMaxHeight()));
    
    validateLayout();
  }
  
  public void invalidateLayout()
  {
    if (this.layoutInvalid < 3)
    {
      invalidateLayoutLocally();
      if (this.parent != null)
      {
        this.layoutInvalid = 3;
        this.parent.childInvalidateLayout(this);
      }
    }
  }
  
  public void validateLayout()
  {
    if (this.layoutInvalid != 0)
    {
      this.layoutInvalid = 0;
      layout();
    }
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++) {
        ((Widget)this.children.get(i)).validateLayout();
      }
    }
  }
  
  public String getTheme()
  {
    return this.theme;
  }
  
  public void setTheme(String theme)
  {
    if (theme == null) {
      throw new IllegalArgumentException("theme is null");
    }
    if (theme.length() > 0)
    {
      int slashIdx = theme.lastIndexOf('/');
      if (slashIdx > 0) {
        throw new IllegalArgumentException("'/' is only allowed as first character in theme name");
      }
      if (slashIdx < 0)
      {
        if (theme.indexOf('.') >= 0) {
          throw new IllegalArgumentException("'.' is only allowed for absolute theme paths");
        }
      }
      else if (theme.length() == 1) {
        throw new IllegalArgumentException("'/' requires a theme path");
      }
      int i = 0;
      for (int n = theme.length(); i < n; i++)
      {
        char ch = theme.charAt(i);
        if ((Character.isISOControl(ch)) || (ch == '*')) {
          throw new IllegalArgumentException("invalid character '" + TextUtil.toPrintableString(ch) + "' in theme name");
        }
      }
    }
    this.theme = theme;
  }
  
  public final String getThemePath()
  {
    return getThemePath(0).toString();
  }
  
  public boolean isClip()
  {
    return this.clip;
  }
  
  public void setClip(boolean clip)
  {
    this.clip = clip;
  }
  
  public boolean isFocusKeyEnabled()
  {
    return this.focusKeyEnabled;
  }
  
  public void setFocusKeyEnabled(boolean focusKeyEnabled)
  {
    this.focusKeyEnabled = focusKeyEnabled;
  }
  
  public Image getBackground()
  {
    return this.background;
  }
  
  public void setBackground(Image background)
  {
    this.background = background;
  }
  
  public Image getOverlay()
  {
    return this.overlay;
  }
  
  public void setOverlay(Image overlay)
  {
    this.overlay = overlay;
  }
  
  public MouseCursor getMouseCursor(Event evt)
  {
    return getMouseCursor();
  }
  
  public MouseCursor getMouseCursor()
  {
    return this.mouseCursor;
  }
  
  public void setMouseCursor(MouseCursor mouseCursor)
  {
    this.mouseCursor = mouseCursor;
  }
  
  public final int getNumChildren()
  {
    if (this.children != null) {
      return this.children.size();
    }
    return 0;
  }
  
  public final Widget getChild(int index)
    throws IndexOutOfBoundsException
  {
    if (this.children != null) {
      return (Widget)this.children.get(index);
    }
    throw new IndexOutOfBoundsException();
  }
  
  public void add(Widget child)
  {
    insertChild(child, getNumChildren());
  }
  
  public void insertChild(Widget child, int index)
    throws IndexOutOfBoundsException
  {
    if (child == null) {
      throw new IllegalArgumentException("child is null");
    }
    if (child == this) {
      throw new IllegalArgumentException("can't add to self");
    }
    if (child.parent != null) {
      throw new IllegalArgumentException("child widget already in tree");
    }
    if (this.children == null) {
      this.children = new ArrayList();
    }
    if ((index < 0) || (index > this.children.size())) {
      throw new IndexOutOfBoundsException();
    }
    child.setParent(this);
    this.children.add(index, child);
    GUI gui = getGUI();
    if (gui != null) {
      child.recursivelySetGUI(gui);
    }
    adjustChildPosition(child, this.posX + this.borderLeft, this.posY + this.borderTop);
    child.recursivelyEnabledChanged(null, this.enabled);
    if (gui != null) {
      child.recursivelyAddToGUI(gui);
    }
    if (this.themeManager != null) {
      child.applyTheme(this.themeManager);
    }
    try
    {
      childAdded(child);
    }
    catch (Exception ex)
    {
      getLogger().log(Level.SEVERE, "Exception in childAdded()", ex);
    }
  }
  
  public final int getChildIndex(Widget child)
  {
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++) {
        if (this.children.get(i) == child) {
          return i;
        }
      }
    }
    return -1;
  }
  
  public boolean removeChild(Widget child)
  {
    int idx = getChildIndex(child);
    if (idx >= 0)
    {
      removeChild(idx);
      return true;
    }
    return false;
  }
  
  public Widget removeChild(int index)
    throws IndexOutOfBoundsException
  {
    if (this.children != null)
    {
      Widget child = (Widget)this.children.remove(index);
      unparentChild(child);
      if (this.lastChildMouseOver == child) {
        this.lastChildMouseOver = null;
      }
      if (this.focusChild == child) {
        this.focusChild = null;
      }
      childRemoved(child);
      return child;
    }
    throw new IndexOutOfBoundsException();
  }
  
  public void removeAllChildren()
  {
    if (this.children != null)
    {
      this.focusChild = null;
      this.lastChildMouseOver = null;
      int i = 0;
      for (int n = this.children.size(); i < n; i++)
      {
        Widget child = (Widget)this.children.get(i);
        unparentChild(child);
      }
      this.children.clear();
      if (this.hasOpenPopup)
      {
        GUI gui = getGUI();
        assert (gui != null);
        recalcOpenPopups(gui);
      }
      allChildrenRemoved();
    }
  }
  
  public void destroy()
  {
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++) {
        ((Widget)this.children.get(i)).destroy();
      }
    }
    if (this.offscreenSurface != null)
    {
      this.offscreenSurface.destroy();
      this.offscreenSurface = null;
    }
  }
  
  public boolean canAcceptKeyboardFocus()
  {
    return this.canAcceptKeyboardFocus;
  }
  
  public void setCanAcceptKeyboardFocus(boolean canAcceptKeyboardFocus)
  {
    this.canAcceptKeyboardFocus = canAcceptKeyboardFocus;
  }
  
  public boolean isDepthFocusTraversal()
  {
    return this.depthFocusTraversal;
  }
  
  public void setDepthFocusTraversal(boolean depthFocusTraversal)
  {
    this.depthFocusTraversal = depthFocusTraversal;
  }
  
  public boolean requestKeyboardFocus()
  {
    if ((this.parent != null) && (this.visible))
    {
      if (this.parent.focusChild == this) {
        return true;
      }
      boolean clear = focusTransferStart();
      try
      {
        return this.parent.requestKeyboardFocus(this);
      }
      finally
      {
        focusTransferClear(clear);
      }
    }
    return false;
  }
  
  public void giveupKeyboardFocus()
  {
    if ((this.parent != null) && (this.parent.focusChild == this)) {
      this.parent.requestKeyboardFocus(null);
    }
  }
  
  public boolean hasKeyboardFocus()
  {
    if (this.parent != null) {
      return this.parent.focusChild == this;
    }
    return false;
  }
  
  public boolean focusNextChild()
  {
    return moveFocus(true, 1);
  }
  
  public boolean focusPrevChild()
  {
    return moveFocus(true, -1);
  }
  
  public boolean focusFirstChild()
  {
    return moveFocus(false, 1);
  }
  
  public boolean focusLastChild()
  {
    return moveFocus(false, -1);
  }
  
  public AnimationState getAnimationState()
  {
    return this.animState;
  }
  
  public boolean hasSharedAnimationState()
  {
    return this.sharedAnimState;
  }
  
  public TintAnimator getTintAnimator()
  {
    return this.tintAnimator;
  }
  
  public void setTintAnimator(TintAnimator tintAnimator)
  {
    this.tintAnimator = tintAnimator;
  }
  
  public RenderOffscreen getRenderOffscreen()
  {
    return this.renderOffscreen;
  }
  
  public void setRenderOffscreen(RenderOffscreen renderOffscreen)
  {
    this.renderOffscreen = renderOffscreen;
  }
  
  public Object getTooltipContent()
  {
    return this.tooltipContent;
  }
  
  public void setTooltipContent(Object tooltipContent)
  {
    this.tooltipContent = tooltipContent;
    updateTooltip();
  }
  
  public InputMap getInputMap()
  {
    return this.inputMap;
  }
  
  public void setInputMap(InputMap inputMap)
  {
    this.inputMap = inputMap;
  }
  
  public ActionMap getActionMap()
  {
    return this.actionMap;
  }
  
  public ActionMap getOrCreateActionMap()
  {
    if (this.actionMap == null) {
      this.actionMap = new ActionMap();
    }
    return this.actionMap;
  }
  
  public void setActionMap(ActionMap actionMap)
  {
    this.actionMap = actionMap;
  }
  
  public Widget getWidgetAt(int x, int y)
  {
    Widget child = getChildAt(x, y);
    if (child != null) {
      return child.getWidgetAt(x, y);
    }
    return this;
  }
  
  protected void applyTheme(ThemeInfo themeInfo)
  {
    applyThemeBackground(themeInfo);
    applyThemeOverlay(themeInfo);
    applyThemeBorder(themeInfo);
    applyThemeOffscreenExtra(themeInfo);
    applyThemeMinSize(themeInfo);
    applyThemeMaxSize(themeInfo);
    applyThemeMouseCursor(themeInfo);
    applyThemeInputMap(themeInfo);
    applyThemeTooltip(themeInfo);
    invalidateLayout();
  }
  
  protected void applyThemeBackground(ThemeInfo themeInfo)
  {
    setBackground(themeInfo.getImage("background"));
  }
  
  protected void applyThemeOverlay(ThemeInfo themeInfo)
  {
    setOverlay(themeInfo.getImage("overlay"));
  }
  
  protected void applyThemeBorder(ThemeInfo themeInfo)
  {
    setBorderSize((Border)themeInfo.getParameterValue("border", false, Border.class));
  }
  
  protected void applyThemeOffscreenExtra(ThemeInfo themeInfo)
  {
    setOffscreenExtra((Border)themeInfo.getParameterValue("offscreenExtra", false, Border.class));
  }
  
  protected void applyThemeMinSize(ThemeInfo themeInfo)
  {
    setMinSize(themeInfo.getParameter("minWidth", 0), themeInfo.getParameter("minHeight", 0));
  }
  
  protected void applyThemeMaxSize(ThemeInfo themeInfo)
  {
    setMaxSize(themeInfo.getParameter("maxWidth", 32767), themeInfo.getParameter("maxHeight", 32767));
  }
  
  protected void applyThemeMouseCursor(ThemeInfo themeInfo)
  {
    setMouseCursor(themeInfo.getMouseCursor("mouseCursor"));
  }
  
  protected void applyThemeInputMap(ThemeInfo themeInfo)
  {
    setInputMap((InputMap)themeInfo.getParameterValue("inputMap", false, InputMap.class));
  }
  
  protected void applyThemeTooltip(ThemeInfo themeInfo)
  {
    this.themeTooltipContent = themeInfo.getParameterValue("tooltip", false);
    if (this.tooltipContent == null) {
      updateTooltip();
    }
  }
  
  protected Object getThemeTooltipContent()
  {
    return this.themeTooltipContent;
  }
  
  protected Object getTooltipContentAt(int mouseX, int mouseY)
  {
    Object content = getTooltipContent();
    if (content == null) {
      content = getThemeTooltipContent();
    }
    return content;
  }
  
  protected void updateTooltip()
  {
    GUI gui = getGUI();
    if (gui != null) {
      gui.requestTooltipUpdate(this, false);
    }
  }
  
  protected void resetTooltip()
  {
    GUI gui = getGUI();
    if (gui != null) {
      gui.requestTooltipUpdate(this, true);
    }
  }
  
  protected void addActionMapping(String action, String methodName, Object... params)
  {
    getOrCreateActionMap().addMapping(action, this, methodName, params, 1);
  }
  
  public void reapplyTheme()
  {
    if (this.themeManager != null) {
      applyTheme(this.themeManager);
    }
  }
  
  protected boolean isMouseInside(Event evt)
  {
    return isInside(evt.getMouseX(), evt.getMouseY());
  }
  
  protected boolean handleEvent(Event evt)
  {
    if (evt.isKeyEvent()) {
      return handleKeyEvent(evt);
    }
    return false;
  }
  
  protected boolean handleKeyStrokeAction(String action, Event event)
  {
    if (this.actionMap != null) {
      return this.actionMap.invoke(action, event);
    }
    return false;
  }
  
  protected void moveChild(int from, int to)
  {
    if (this.children == null) {
      throw new IndexOutOfBoundsException();
    }
    if ((to < 0) || (to >= this.children.size())) {
      throw new IndexOutOfBoundsException("to");
    }
    if ((from < 0) || (from >= this.children.size())) {
      throw new IndexOutOfBoundsException("from");
    }
    Widget child = (Widget)this.children.remove(from);
    this.children.add(to, child);
  }
  
  protected boolean requestKeyboardFocus(Widget child)
  {
    if ((child != null) && (child.parent != this)) {
      throw new IllegalArgumentException("not a direct child");
    }
    if (this.focusChild != child) {
      if (child == null)
      {
        recursivelyChildFocusLost(this.focusChild);
        this.focusChild = null;
        keyboardFocusChildChanged(null);
      }
      else
      {
        boolean clear = focusTransferStart();
        try
        {
          FocusGainedCause savedCause = this.focusGainedCause;
          if (savedCause == null) {
            this.focusGainedCause = FocusGainedCause.CHILD_FOCUSED;
          }
          try
          {
            if (!requestKeyboardFocus())
            {
              boolean bool1 = false;
              

              this.focusGainedCause = savedCause;
              

















              return bool1;
            }
          }
          finally
          {
            this.focusGainedCause = savedCause;
          }
          recursivelyChildFocusLost(this.focusChild);
          this.focusChild = child;
          keyboardFocusChildChanged(child);
          if (!child.sharedAnimState) {
            child.animState.setAnimationState(STATE_KEYBOARD_FOCUS, true);
          }
          FocusGainedCause cause = child.focusGainedCause;
          Widget[] fti = (Widget[])focusTransferInfo.get();
          child.keyboardFocusGained(cause != null ? cause : FocusGainedCause.MANUAL, fti != null ? fti[0] : null);
        }
        finally
        {
          focusTransferClear(clear);
        }
      }
    }
    if (!this.sharedAnimState) {
      this.animState.setAnimationState(STATE_HAS_FOCUSED_CHILD, this.focusChild != null);
    }
    return this.focusChild != null;
  }
  
  protected void beforeRemoveFromGUI(GUI gui) {}
  
  protected void afterAddToGUI(GUI gui) {}
  
  protected void layout() {}
  
  protected void positionChanged() {}
  
  protected void sizeChanged()
  {
    invalidateLayoutLocally();
  }
  
  protected void borderChanged()
  {
    invalidateLayout();
  }
  
  protected void childInvalidateLayout(Widget child)
  {
    invalidateLayout();
  }
  
  protected void childAdded(Widget child)
  {
    invalidateLayout();
  }
  
  protected void childRemoved(Widget exChild)
  {
    invalidateLayout();
  }
  
  protected void allChildrenRemoved()
  {
    invalidateLayout();
  }
  
  protected void childVisibilityChanged(Widget child) {}
  
  protected void keyboardFocusChildChanged(Widget child) {}
  
  protected void keyboardFocusLost() {}
  
  protected void keyboardFocusGained() {}
  
  protected void keyboardFocusGained(FocusGainedCause cause, Widget previousWidget)
  {
    keyboardFocusGained();
  }
  
  protected void widgetDisabled() {}
  
  protected void paint(GUI gui)
  {
    paintBackground(gui);
    paintWidget(gui);
    paintChildren(gui);
    paintOverlay(gui);
  }
  
  protected void paintWidget(GUI gui) {}
  
  protected void paintBackground(GUI gui)
  {
    Image bgImage = getBackground();
    if (bgImage != null) {
      bgImage.draw(getAnimationState(), this.posX, this.posY, this.width, this.height);
    }
  }
  
  protected void paintOverlay(GUI gui)
  {
    Image ovImage = getOverlay();
    if (ovImage != null) {
      ovImage.draw(getAnimationState(), this.posX, this.posY, this.width, this.height);
    }
  }
  
  protected void paintChildren(GUI gui)
  {
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++)
      {
        Widget child = (Widget)this.children.get(i);
        if (child.visible) {
          child.drawWidget(gui);
        }
      }
    }
  }
  
  protected void paintChild(GUI gui, Widget child)
  {
    if (child.parent != this) {
      throw new IllegalArgumentException("can only render direct children");
    }
    child.drawWidget(gui);
  }
  
  protected void paintDragOverlay(GUI gui, int mouseX, int mouseY, int modifier) {}
  
  protected final void invalidateLayoutLocally()
  {
    if (this.layoutInvalid < 1)
    {
      this.layoutInvalid = 1;
      GUI gui = getGUI();
      if (gui != null) {
        gui.hasInvalidLayouts = true;
      }
    }
  }
  
  protected void layoutChildFullInnerArea(Widget child)
  {
    if (child.parent != this) {
      throw new IllegalArgumentException("can only layout direct children");
    }
    child.setPosition(getInnerX(), getInnerY());
    child.setSize(getInnerWidth(), getInnerHeight());
  }
  
  protected void layoutChildrenFullInnerArea()
  {
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++) {
        layoutChildFullInnerArea((Widget)this.children.get(i));
      }
    }
  }
  
  protected List<Widget> getKeyboardFocusOrder()
  {
    if (this.children == null) {
      return Collections.emptyList();
    }
    return Collections.unmodifiableList(this.children);
  }
  
  private int collectFocusOrderList(ArrayList<Widget> list)
  {
    int idx = -1;
    for (Widget child : getKeyboardFocusOrder()) {
      if ((child.visible) && (child.isEnabled()))
      {
        if (child.canAcceptKeyboardFocus)
        {
          if (child == this.focusChild) {
            idx = list.size();
          }
          list.add(child);
        }
        if (child.depthFocusTraversal)
        {
          int subIdx = child.collectFocusOrderList(list);
          if (subIdx != -1) {
            idx = subIdx;
          }
        }
      }
    }
    return idx;
  }
  
  private boolean moveFocus(boolean relative, int dir)
  {
    ArrayList<Widget> focusList = new ArrayList();
    int curIndex = collectFocusOrderList(focusList);
    if (focusList.isEmpty()) {
      return false;
    }
    if (dir < 0)
    {
      if (relative)
      {
        curIndex--;
        if (curIndex >= 0) {}
      }
      else
      {
        curIndex = focusList.size() - 1;
      }
    }
    else if (relative)
    {
      curIndex++;
      if (curIndex < focusList.size()) {}
    }
    else
    {
      curIndex = 0;
    }
    Widget widget = (Widget)focusList.get(curIndex);
    try
    {
      widget.focusGainedCause = FocusGainedCause.FOCUS_KEY;
      widget.requestKeyboardFocus(null);
      widget.requestKeyboardFocus();
    }
    finally
    {
      widget.focusGainedCause = null;
    }
    return true;
  }
  
  private boolean focusTransferStart()
  {
    Widget[] fti = (Widget[])focusTransferInfo.get();
    if (fti == null)
    {
      Widget root = getRootWidget();
      Widget w = root;
      while (w.focusChild != null) {
        w = w.focusChild;
      }
      if (w == root) {
        w = null;
      }
      focusTransferInfo.set(new Widget[] { w });
      return true;
    }
    return false;
  }
  
  private void focusTransferClear(boolean clear)
  {
    if (clear) {
      focusTransferInfo.set(null);
    }
  }
  
  protected final Widget getChildAt(int x, int y)
  {
    int i;
    if (this.children != null) {
      for (i = this.children.size(); i-- > 0;)
      {
        Widget child = (Widget)this.children.get(i);
        if ((child.visible) && (child.isInside(x, y))) {
          return child;
        }
      }
    }
    return null;
  }
  
  protected void updateTintAnimation()
  {
    this.tintAnimator.update();
  }
  
  protected final void firePropertyChange(PropertyChangeEvent evt)
  {
    if (this.propertyChangeSupport != null) {
      this.propertyChangeSupport.firePropertyChange(evt);
    }
  }
  
  protected final void firePropertyChange(String propertyName, boolean oldValue, boolean newValue)
  {
    if (this.propertyChangeSupport != null) {
      this.propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);
    }
  }
  
  protected final void firePropertyChange(String propertyName, int oldValue, int newValue)
  {
    if (this.propertyChangeSupport != null) {
      this.propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);
    }
  }
  
  protected final void firePropertyChange(String propertyName, Object oldValue, Object newValue)
  {
    if (this.propertyChangeSupport != null) {
      this.propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);
    }
  }
  
  void setParent(Widget parent)
  {
    this.parent = parent;
  }
  
  private void unparentChild(Widget child)
  {
    GUI gui = getGUI();
    if (child.hasOpenPopup)
    {
      assert (gui != null);
      gui.closePopupFromWidgets(child);
    }
    recursivelyChildFocusLost(child);
    if (gui != null) {
      child.recursivelyRemoveFromGUI(gui);
    }
    child.recursivelyClearGUI(gui);
    child.parent = null;
    try
    {
      child.destroy();
    }
    catch (Exception ex)
    {
      getLogger().log(Level.SEVERE, "Exception in destroy()", ex);
    }
    adjustChildPosition(child, -this.posX, -this.posY);
    child.recursivelyEnabledChanged(null, child.locallyEnabled);
  }
  
  private void recursivelySetGUI(GUI gui)
  {
    assert (this.guiInstance == null) : "guiInstance must be null";
    this.guiInstance = gui;
    int i;
    if (this.children != null) {
      for (i = this.children.size(); i-- > 0;) {
        ((Widget)this.children.get(i)).recursivelySetGUI(gui);
      }
    }
  }
  
  private void recursivelyAddToGUI(GUI gui)
  {
    assert (this.guiInstance == gui) : "guiInstance must be equal to gui";
    if (this.layoutInvalid != 0) {
      gui.hasInvalidLayouts = true;
    }
    if (!this.sharedAnimState) {
      this.animState.setGUI(gui);
    }
    try
    {
      afterAddToGUI(gui);
    }
    catch (Exception ex)
    {
      getLogger().log(Level.SEVERE, "Exception in afterAddToGUI()", ex);
    }
    int i;
    if (this.children != null) {
      for (i = this.children.size(); i-- > 0;) {
        ((Widget)this.children.get(i)).recursivelyAddToGUI(gui);
      }
    }
  }
  
  private void recursivelyClearGUI(GUI gui)
  {
    assert (this.guiInstance == gui) : "guiInstance must be null";
    this.guiInstance = null;
    this.themeManager = null;
    int i;
    if (this.children != null) {
      for (i = this.children.size(); i-- > 0;) {
        ((Widget)this.children.get(i)).recursivelyClearGUI(gui);
      }
    }
  }
  
  private void recursivelyRemoveFromGUI(GUI gui)
  {
    assert (this.guiInstance == gui) : "guiInstance must be equal to gui";
    int i;
    if (this.children != null) {
      for (i = this.children.size(); i-- > 0;) {
        ((Widget)this.children.get(i)).recursivelyRemoveFromGUI(gui);
      }
    }
    this.focusChild = null;
    if (!this.sharedAnimState) {
      this.animState.setGUI(null);
    }
    try
    {
      beforeRemoveFromGUI(gui);
    }
    catch (Exception ex)
    {
      getLogger().log(Level.SEVERE, "Exception in beforeRemoveFromGUI()", ex);
    }
  }
  
  private void recursivelyChildFocusLost(Widget w)
  {
    while (w != null)
    {
      Widget next = w.focusChild;
      if (!w.sharedAnimState) {
        w.animState.setAnimationState(STATE_KEYBOARD_FOCUS, false);
      }
      try
      {
        w.keyboardFocusLost();
      }
      catch (Exception ex)
      {
        getLogger().log(Level.SEVERE, "Exception in keyboardFocusLost()", ex);
      }
      w.focusChild = null;
      w = next;
    }
  }
  
  private void recursivelyEnabledChanged(GUI gui, boolean enabled)
  {
    enabled &= this.locallyEnabled;
    int i;
    if (this.enabled != enabled)
    {
      this.enabled = enabled;
      if (!this.sharedAnimState) {
        getAnimationState().setAnimationState(STATE_DISABLED, !enabled);
      }
      if (!enabled)
      {
        if (gui != null) {
          gui.widgetDisabled(this);
        }
        try
        {
          widgetDisabled();
        }
        catch (Exception ex)
        {
          getLogger().log(Level.SEVERE, "Exception in widgetDisabled()", ex);
        }
        try
        {
          giveupKeyboardFocus();
        }
        catch (Exception ex)
        {
          getLogger().log(Level.SEVERE, "Exception in giveupKeyboardFocus()", ex);
        }
      }
      try
      {
        firePropertyChange("enabled", !enabled, enabled);
      }
      catch (Exception ex)
      {
        getLogger().log(Level.SEVERE, "Exception in firePropertyChange(\"enabled\")", ex);
      }
      if (this.children != null) {
        for (i = this.children.size(); i-- > 0;)
        {
          Widget child = (Widget)this.children.get(i);
          child.recursivelyEnabledChanged(gui, enabled);
        }
      }
    }
  }
  
  private void childHidden(Widget child)
  {
    if (this.focusChild == child)
    {
      recursivelyChildFocusLost(this.focusChild);
      this.focusChild = null;
    }
    if (this.lastChildMouseOver == child) {
      this.lastChildMouseOver = null;
    }
  }
  
  final void setOpenPopup(GUI gui, boolean hasOpenPopup)
  {
    if (this.hasOpenPopup != hasOpenPopup)
    {
      this.hasOpenPopup = hasOpenPopup;
      if (!this.sharedAnimState) {
        getAnimationState().setAnimationState(STATE_HAS_OPEN_POPUPS, hasOpenPopup);
      }
      if (this.parent != null) {
        if (hasOpenPopup) {
          this.parent.setOpenPopup(gui, true);
        } else {
          this.parent.recalcOpenPopups(gui);
        }
      }
    }
  }
  
  final void recalcOpenPopups(GUI gui)
  {
    if (gui.hasOpenPopups(this))
    {
      setOpenPopup(gui, true); return;
    }
    int i;
    if (this.children != null) {
      for (i = this.children.size(); i-- > 0;) {
        if (((Widget)this.children.get(i)).hasOpenPopup)
        {
          setOpenPopup(gui, true);
          return;
        }
      }
    }
    setOpenPopup(gui, false);
  }
  
  final boolean isLayoutInvalid()
  {
    return this.layoutInvalid != 0;
  }
  
  final void drawWidget(GUI gui)
  {
    if (this.renderOffscreen != null)
    {
      drawWidgetOffscreen(gui);
      return;
    }
    if ((this.tintAnimator != null) && (this.tintAnimator.hasTint()))
    {
      drawWidgetTint(gui);
      return;
    }
    if (this.clip)
    {
      drawWidgetClip(gui);
      return;
    }
    paint(gui);
  }
  
  private void drawWidgetTint(GUI gui)
  {
    if (this.tintAnimator.isFadeActive()) {
      updateTintAnimation();
    }
    Renderer renderer = gui.getRenderer();
    this.tintAnimator.paintWithTint(renderer);
    try
    {
      if (this.clip) {
        drawWidgetClip(gui);
      } else {
        paint(gui);
      }
    }
    finally
    {
      renderer.popGlobalTintColor();
    }
  }
  
  private void drawWidgetClip(GUI gui)
  {
    Renderer renderer = gui.getRenderer();
    renderer.clipEnter(this.posX, this.posY, this.width, this.height);
    try
    {
      paint(gui);
    }
    finally
    {
      renderer.clipLeave();
    }
  }
  
  private void drawWidgetOffscreen(GUI gui)
  {
    RenderOffscreen ro = this.renderOffscreen;
    Renderer renderer = gui.getRenderer();
    OffscreenRenderer offscreenRenderer = renderer.getOffscreenRenderer();
    if (offscreenRenderer != null)
    {
      int extraTop = this.offscreenExtraTop;
      int extraLeft = this.offscreenExtraLeft;
      int extraRight = this.offscreenExtraRight;
      int extraBottom = this.offscreenExtraBottom;
      int[] effectExtra = ro.getEffectExtraArea(this);
      if (effectExtra != null)
      {
        extraTop += effectExtra[0];
        extraLeft += effectExtra[1];
        extraRight += effectExtra[2];
        extraBottom += effectExtra[3];
      }
      if ((this.offscreenSurface != null) && (!ro.needPainting(gui, this.parent, this.offscreenSurface)))
      {
        ro.paintOffscreenSurface(gui, this, this.offscreenSurface);
        return;
      }
      this.offscreenSurface = offscreenRenderer.startOffscreenRendering(this, this.offscreenSurface, this.posX - extraLeft, this.posY - extraTop, this.width + extraLeft + extraRight, this.height + extraTop + extraBottom);
      if (this.offscreenSurface != null)
      {
        try
        {
          if ((this.tintAnimator != null) && (this.tintAnimator.hasTint())) {
            drawWidgetTint(gui);
          } else {
            paint(gui);
          }
        }
        finally
        {
          offscreenRenderer.endOffscreenRendering();
        }
        ro.paintOffscreenSurface(gui, this, this.offscreenSurface);
        return;
      }
    }
    this.renderOffscreen = null;
    ro.offscreenRenderingFailed(this);
    drawWidget(gui);
  }
  
  Widget getWidgetUnderMouse()
  {
    if (!this.visible) {
      return null;
    }
    Widget w = this;
    while ((w.lastChildMouseOver != null) && (w.visible)) {
      w = w.lastChildMouseOver;
    }
    return w;
  }
  
  private static void adjustChildPosition(Widget child, int deltaX, int deltaY)
  {
    child.setPositionImpl(child.posX + deltaX, child.posY + deltaY);
  }
  
  final boolean setPositionImpl(int x, int y)
  {
    int deltaX = x - this.posX;
    int deltaY = y - this.posY;
    if ((deltaX != 0) || (deltaY != 0))
    {
      this.posX = x;
      this.posY = y;
      if (this.children != null)
      {
        int i = 0;
        for (int n = this.children.size(); i < n; i++) {
          adjustChildPosition((Widget)this.children.get(i), deltaX, deltaY);
        }
      }
      positionChanged();
      if (this.propertyChangeSupport != null)
      {
        firePropertyChange("x", x - deltaX, x);
        firePropertyChange("y", y - deltaY, y);
      }
      return true;
    }
    return false;
  }
  
  void applyTheme(ThemeManager themeManager)
  {
    this.themeManager = themeManager;
    
    String themePath = getThemePath();
    if (themePath.length() == 0)
    {
      if (this.children != null)
      {
        int i = 0;
        for (int n = this.children.size(); i < n; i++) {
          ((Widget)this.children.get(i)).applyTheme(themeManager);
        }
      }
      return;
    }
    DebugHook hook = DebugHook.getDebugHook();
    hook.beforeApplyTheme(this);
    
    ThemeInfo themeInfo = null;
    try
    {
      themeInfo = themeManager.findThemeInfo(themePath);
      if ((themeInfo != null) && (this.theme.length() > 0)) {
        try {}catch (Exception ex)
        {
          getLogger().log(Level.SEVERE, "Exception in applyTheme()", ex);
        }
      }
    }
    finally
    {
      hook.afterApplyTheme(this);
    }
    applyThemeToChildren(themeManager, themeInfo, hook);
  }
  
  public static boolean isAbsoluteTheme(String theme)
  {
    return (theme.length() > 1) && (theme.charAt(0) == '/');
  }
  
  private void applyThemeImpl(ThemeManager themeManager, ThemeInfo themeInfo, DebugHook hook)
  {
    this.themeManager = themeManager;
    if (this.theme.length() > 0)
    {
      hook.beforeApplyTheme(this);
      try
      {
        if (isAbsoluteTheme(this.theme)) {
          themeInfo = themeManager.findThemeInfo(this.theme.substring(1));
        } else {
          themeInfo = themeInfo.getChildTheme(this.theme);
        }
        if (themeInfo != null) {
          try {}catch (Exception ex)
          {
            getLogger().log(Level.SEVERE, "Exception in applyTheme()", ex);
          }
        }
      }
      finally
      {
        hook.afterApplyTheme(this);
      }
    }
    applyThemeToChildren(themeManager, themeInfo, hook);
  }
  
  private void applyThemeToChildren(ThemeManager themeManager, ThemeInfo themeInfo, DebugHook hook)
  {
    if ((this.children != null) && (themeInfo != null))
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++)
      {
        Widget child = (Widget)this.children.get(i);
        child.applyThemeImpl(themeManager, themeInfo, hook);
      }
    }
  }
  
  private StringBuilder getThemePath(int length)
  {
    length += this.theme.length();
    boolean abs = isAbsoluteTheme(this.theme);
    StringBuilder sb;
    if ((this.parent != null) && (!abs))
    {
      StringBuilder sb = this.parent.getThemePath(length + 1);
      if ((this.theme.length() > 0) && (sb.length() > 0)) {
        sb.append('.');
      }
    }
    else
    {
      sb = new StringBuilder(length);
    }
    if (abs) {
      return sb.append(this.theme.substring(1));
    }
    return sb.append(this.theme);
  }
  
  Event translateMouseEvent(Event evt)
  {
    if ((this.renderOffscreen instanceof OffscreenMouseAdjustments))
    {
      int[] newXY = ((OffscreenMouseAdjustments)this.renderOffscreen).adjustMouseCoordinates(this, evt);
      evt = evt.createSubEvent(newXY[0], newXY[1]);
    }
    return evt;
  }
  
  Widget routeMouseEvent(Event evt)
  {
    assert (!evt.isMouseDragEvent());
    evt = translateMouseEvent(evt);
    int i;
    if (this.children != null) {
      for (i = this.children.size(); i-- > 0;)
      {
        Widget child = (Widget)this.children.get(i);
        if ((child.visible) && (child.isMouseInside(evt))) {
          if (setMouseOverChild(child, evt))
          {
            if ((evt.getType() == Event.Type.MOUSE_ENTERED) || (evt.getType() == Event.Type.MOUSE_EXITED)) {
              return child;
            }
            Widget result = child.routeMouseEvent(evt);
            if (result != null)
            {
              if ((evt.getType() == Event.Type.MOUSE_BTNDOWN) && (this.focusChild != child)) {
                try
                {
                  child.focusGainedCause = FocusGainedCause.MOUSE_BTNDOWN;
                  if ((child.isEnabled()) && (child.canAcceptKeyboardFocus())) {
                    requestKeyboardFocus(child);
                  }
                }
                finally
                {
                  child.focusGainedCause = null;
                }
              }
              return result;
            }
          }
        }
      }
    }
    if ((evt.getType() == Event.Type.MOUSE_BTNDOWN) && (isEnabled()) && (canAcceptKeyboardFocus())) {
      try
      {
        this.focusGainedCause = FocusGainedCause.MOUSE_BTNDOWN;
        if (this.focusChild == null) {
          requestKeyboardFocus();
        } else {
          requestKeyboardFocus(null);
        }
      }
      finally
      {
        this.focusGainedCause = null;
      }
    }
    if (evt.getType() != Event.Type.MOUSE_WHEEL) {
      setMouseOverChild(null, evt);
    }
    if ((!isEnabled()) && (isMouseAction(evt))) {
      return this;
    }
    if (handleEvent(evt)) {
      return this;
    }
    return null;
  }
  
  static boolean isMouseAction(Event evt)
  {
    Event.Type type = evt.getType();
    return (type == Event.Type.MOUSE_BTNDOWN) || (type == Event.Type.MOUSE_BTNUP) || (type == Event.Type.MOUSE_CLICKED) || (type == Event.Type.MOUSE_DRAGGED);
  }
  
  void routePopupEvent(Event evt)
  {
    handleEvent(evt);
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++) {
        ((Widget)this.children.get(i)).routePopupEvent(evt);
      }
    }
  }
  
  static boolean getSafeBooleanProperty(String name)
  {
    try
    {
      return Boolean.getBoolean(name);
    }
    catch (AccessControlException ex) {}
    return false;
  }
  
  private static final boolean WARN_ON_UNHANDLED_ACTION = getSafeBooleanProperty("warnOnUnhandledAction");
  
  private boolean handleKeyEvent(Event evt)
  {
    if (this.children != null)
    {
      if ((this.focusKeyEnabled) && (this.guiInstance != null)) {
        this.guiInstance.setFocusKeyWidget(this);
      }
      if ((this.focusChild != null) && (this.focusChild.isVisible()) && 
        (this.focusChild.handleEvent(evt))) {
        return true;
      }
    }
    if (this.inputMap != null)
    {
      String action = this.inputMap.mapEvent(evt);
      if (action != null)
      {
        if (handleKeyStrokeAction(action, evt)) {
          return true;
        }
        if (WARN_ON_UNHANDLED_ACTION) {
          Logger.getLogger(getClass().getName()).log(Level.WARNING, "Unhandled action ''{0}'' for class ''{1}''", new Object[] { action, getClass().getName() });
        }
      }
    }
    return false;
  }
  
  void handleFocusKeyEvent(Event evt)
  {
    if (evt.isKeyPressedEvent()) {
      if ((evt.getModifiers() & 0x9) != 0) {
        focusPrevChild();
      } else {
        focusNextChild();
      }
    }
  }
  
  boolean setMouseOverChild(Widget child, Event evt)
  {
    if (this.lastChildMouseOver != child)
    {
      if (child != null)
      {
        Widget result = child.routeMouseEvent(evt.createSubEvent(Event.Type.MOUSE_ENTERED));
        if (result == null) {
          return false;
        }
      }
      if (this.lastChildMouseOver != null) {
        this.lastChildMouseOver.routeMouseEvent(evt.createSubEvent(Event.Type.MOUSE_EXITED));
      }
      this.lastChildMouseOver = child;
    }
    return true;
  }
  
  void collectLayoutLoop(ArrayList<Widget> result)
  {
    if (this.layoutInvalid != 0) {
      result.add(this);
    }
    if (this.children != null)
    {
      int i = 0;
      for (int n = this.children.size(); i < n; i++) {
        ((Widget)this.children.get(i)).collectLayoutLoop(result);
      }
    }
  }
  
  private PropertyChangeSupport createPropertyChangeSupport()
  {
    if (this.propertyChangeSupport == null) {
      this.propertyChangeSupport = new PropertyChangeSupport(this);
    }
    return this.propertyChangeSupport;
  }
  
  private Logger getLogger()
  {
    return Logger.getLogger(Widget.class.getName());
  }
  
  public static abstract interface OffscreenMouseAdjustments
    extends Widget.RenderOffscreen
  {
    public abstract int[] adjustMouseCoordinates(Widget paramWidget, Event paramEvent);
  }
  
  public static abstract interface RenderOffscreen
  {
    public abstract void paintOffscreenSurface(GUI paramGUI, Widget paramWidget, OffscreenSurface paramOffscreenSurface);
    
    public abstract void offscreenRenderingFailed(Widget paramWidget);
    
    public abstract int[] getEffectExtraArea(Widget paramWidget);
    
    public abstract boolean needPainting(GUI paramGUI, Widget paramWidget, OffscreenSurface paramOffscreenSurface);
  }
}
